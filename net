import pandas as pd
import numpy as np
import json
from datetime import datetime, timedelta
import random
from collections import defaultdict

# Set random seed for reproducibility
np.random.seed(42)
random.seed(42)

class BankingTradeAnalyzer:
    """
    Complete banking trade analysis pipeline that generates data,
    performs analysis, and exports results for visualization
    """
    
    def __init__(self, n_rows=40000):
        self.n_rows = n_rows
        self.df = None
        self.analysis_results = {}
        
    def generate_data(self):
        """Generate realistic banking trade data"""
        print("="*60)
        print("GENERATING BANKING TRADE DATA")
        print("="*60)
        
        # Define realistic parameters
        customer_names = [
            "Tech Corp Ltd", "Global Manufacturing Inc", "Alpha Trading Co", "Beta Industries",
            "Gamma Electronics", "Delta Logistics", "Epsilon Energy", "Zeta Pharma",
            "Eta Mining Corp", "Theta Retail Group", "Iota Finance Ltd", "Kappa Foods",
            "Lambda Textiles", "Mu Chemicals", "Nu Construction", "Xi Telecom",
            "Omicron Shipping", "Pi Aerospace", "Rho Agriculture", "Sigma Motors"
        ]
        
        industries = [
            "Technology", "Manufacturing", "Trading", "Energy", "Healthcare",
            "Retail", "Finance", "Logistics", "Mining", "Telecommunications",
            "Aerospace", "Agriculture", "Chemicals", "Construction", "Textiles"
        ]
        
        counterparty_banks = [
            "HSBC", "Standard Chartered", "Bank of China", "ICBC", "DBS Bank",
            "Citibank", "JP Morgan", "Deutsche Bank", "BNP Paribas", "Santander",
            "UBS", "Credit Suisse", "Barclays", "Royal Bank of Canada", "ANZ Bank"
        ]
        
        address_patterns = [
            "{bank} Tower, Central, Hong Kong",
            "{bank} Building, HK",
            "{bank} Plaza, Beijing, China",
            "{bank} Center, Shanghai, CN",
            "{bank} House, Singapore",
            "{bank} Ltd, SG",
            "{bank} Tower, Tokyo, Japan",
            "{bank} Building, JP"
        ]
        
        # Generate date range
        end_date = datetime.now()
        start_date = end_date - timedelta(days=730)
        
        # Create customer patterns
        customer_patterns = {}
        for customer in customer_names:
            customer_patterns[customer] = {
                'avg_amount': np.random.lognormal(11, 1.5),
                'preferred_banks': np.random.choice(counterparty_banks, size=5, replace=False),
                'industry': np.random.choice(industries)
            }
        
        # Generate trades
        data = []
        for i in range(self.n_rows):
            customer = np.random.choice(customer_names, 
                                      p=np.random.dirichlet(np.ones(len(customer_names))*10))
            pattern = customer_patterns[customer]
            
            days_offset = int(np.random.exponential(365))
            date = end_date - timedelta(days=min(days_offset, 729))
            
            amount = max(1000, np.random.lognormal(np.log(pattern['avg_amount']), 0.5))
            
            if np.random.random() < 0.7:
                bank = np.random.choice(pattern['preferred_banks'])
            else:
                bank = np.random.choice(counterparty_banks)
            
            address = np.random.choice(address_patterns).format(bank=bank)
            
            data.append({
                'Date': date,
                'Customer Name': customer,
                'Customer Industry': pattern['industry'],
                'Amount': round(amount, 2),
                'Counterparty Bank': bank,
                'Counterparty Address': address
            })
        
        self.df = pd.DataFrame(data).sort_values('Date').reset_index(drop=True)
        print(f"Generated {len(self.df):,} transactions")
        
        # Extract country from address
        self.df['Country'] = self.df['Counterparty Address'].apply(self._extract_country)
        
        # Add time features
        self.df['Year'] = self.df['Date'].dt.year
        self.df['Month'] = self.df['Date'].dt.month
        self.df['Quarter'] = self.df['Date'].dt.quarter
        
        return self.df
    
    def _extract_country(self, address):
        """Extract country from address string"""
        address_lower = address.lower()
        country_patterns = {
            'Hong Kong': ['hong kong', 'hk'],
            'China': ['china', 'cn', 'beijing', 'shanghai'],
            'Singapore': ['singapore', 'sg'],
            'Japan': ['japan', 'jp', 'tokyo']
        }
        
        for country, patterns in country_patterns.items():
            for pattern in patterns:
                if pattern in address_lower:
                    return country
        return 'Others'
    
    def analyze_data(self):
        """Perform comprehensive analysis"""
        print("\n" + "="*60)
        print("PERFORMING ANALYSIS")
        print("="*60)
        
        # 1. Basic metrics
        self.analysis_results['basic_metrics'] = {
            'total_transactions': len(self.df),
            'total_volume': float(self.df['Amount'].sum()),
            'avg_transaction': float(self.df['Amount'].mean()),
            'std_transaction': float(self.df['Amount'].std()),
            'date_range': {
                'start': self.df['Date'].min().isoformat(),
                'end': self.df['Date'].max().isoformat()
            }
        }
        
        # 2. Monthly trends
        monthly_volume = self.df.groupby(self.df['Date'].dt.to_period('M'))['Amount'].sum()
        monthly_count = self.df.groupby(self.df['Date'].dt.to_period('M'))['Amount'].count()
        
        self.analysis_results['monthly_trends'] = {
            'months': [str(m) for m in monthly_volume.index],
            'volumes': [float(v) for v in monthly_volume.values],
            'counts': [int(c) for c in monthly_count.values]
        }
        
        # 3. Customer segmentation
        customer_metrics = self.df.groupby('Customer Name').agg({
            'Amount': ['sum', 'mean', 'count', 'std'],
            'Country': lambda x: x.mode()[0] if len(x) > 0 else 'Unknown',
            'Customer Industry': 'first'
        }).round(2)
        
        customer_metrics.columns = ['Total_Volume', 'Avg_Transaction', 'Num_Transactions', 
                                   'Std_Dev', 'Primary_Country', 'Industry']
        
        # Calculate stability and segment
        customer_metrics['Stability'] = (customer_metrics['Std_Dev'] / 
                                        customer_metrics['Avg_Transaction']).fillna(0)
        
        def segment_customer(row):
            if row['Total_Volume'] > customer_metrics['Total_Volume'].quantile(0.75):
                return 'Premium Stable' if row['Stability'] < 0.5 else 'Premium Volatile'
            elif row['Num_Transactions'] > customer_metrics['Num_Transactions'].quantile(0.75):
                return 'High Frequency'
            else:
                return 'Standard'
        
        customer_metrics['Segment'] = customer_metrics.apply(segment_customer, axis=1)
        
        # Convert to serializable format
        customer_data = []
        for customer, row in customer_metrics.iterrows():
            customer_data.append({
                'name': customer,
                'total_volume': float(row['Total_Volume']),
                'avg_transaction': float(row['Avg_Transaction']),
                'num_transactions': int(row['Num_Transactions']),
                'stability': float(row['Stability']),
                'primary_country': row['Primary_Country'],
                'industry': row['Industry'],
                'segment': row['Segment']
            })
        
        self.analysis_results['customer_analysis'] = customer_data
        
        # 4. Segment summary
        segment_summary = customer_metrics.groupby('Segment').agg({
            'Total_Volume': 'sum',
            'Avg_Transaction': 'mean',
            'Num_Transactions': 'sum'
        })
        
        self.analysis_results['segment_summary'] = {
            segment: {
                'total_volume': float(row['Total_Volume']),
                'avg_transaction': float(row['Avg_Transaction']),
                'total_transactions': int(row['Num_Transactions']),
                'customer_count': len(customer_metrics[customer_metrics['Segment'] == segment])
            }
            for segment, row in segment_summary.iterrows()
        }
        
        # 5. Industry analysis
        industry_metrics = self.df.groupby('Customer Industry').agg({
            'Amount': ['sum', 'mean', 'count']
        }).round(2)
        industry_metrics.columns = ['Total_Volume', 'Avg_Transaction', 'Num_Transactions']
        
        self.analysis_results['industry_analysis'] = {
            industry: {
                'total_volume': float(row['Total_Volume']),
                'avg_transaction': float(row['Avg_Transaction']),
                'num_transactions': int(row['Num_Transactions'])
            }
            for industry, row in industry_metrics.iterrows()
        }
        
        # 6. Geographic distribution
        geo_metrics = self.df.groupby('Country')['Amount'].agg(['sum', 'count', 'mean'])
        
        self.analysis_results['geographic_distribution'] = {
            country: {
                'total_volume': float(row['sum']),
                'transaction_count': int(row['count']),
                'avg_transaction': float(row['mean']),
                'percentage': float(row['sum'] / self.df['Amount'].sum() * 100)
            }
            for country, row in geo_metrics.iterrows()
        }
        
        # 7. Bank relationships
        bank_metrics = self.df.groupby('Counterparty Bank')['Amount'].agg(['sum', 'count'])
        
        self.analysis_results['bank_analysis'] = {
            bank: {
                'total_volume': float(row['sum']),
                'transaction_count': int(row['count']),
                'market_share': float(row['sum'] / self.df['Amount'].sum() * 100)
            }
            for bank, row in bank_metrics.head(10).iterrows()
        }
        
        # 8. Cross-border flows (Industry to Country)
        flow_matrix = pd.crosstab(self.df['Customer Industry'], self.df['Country'], 
                                 values=self.df['Amount'], aggfunc='sum').fillna(0)
        
        flows = []
        for industry in flow_matrix.index:
            for country in flow_matrix.columns:
                if flow_matrix.loc[industry, country] > 0:
                    flows.append({
                        'source': industry,
                        'target': country,
                        'value': float(flow_matrix.loc[industry, country])
                    })
        
        self.analysis_results['cross_border_flows'] = flows
        
        # 9. Growth analysis
        recent_period = self.df[self.df['Date'] > self.df['Date'].max() - timedelta(days=90)]
        older_period = self.df[(self.df['Date'] > self.df['Date'].max() - timedelta(days=180)) & 
                              (self.df['Date'] <= self.df['Date'].max() - timedelta(days=90))]
        
        recent_volume = recent_period.groupby('Customer Name')['Amount'].sum()
        older_volume = older_period.groupby('Customer Name')['Amount'].sum()
        
        growth_rates = {}
        for customer in recent_volume.index:
            if customer in older_volume.index and older_volume[customer] > 0:
                growth = ((recent_volume[customer] - older_volume[customer]) / 
                         older_volume[customer] * 100)
                growth_rates[customer] = {
                    'recent_volume': float(recent_volume[customer]),
                    'previous_volume': float(older_volume[customer]),
                    'growth_rate': float(growth)
                }
        
        self.analysis_results['growth_analysis'] = growth_rates
        
        # 10. Risk indicators
        # Concentration risk
        top5_customers = customer_metrics.nlargest(5, 'Total_Volume')
        concentration = top5_customers['Total_Volume'].sum() / self.df['Amount'].sum() * 100
        
        # Volatility analysis
        volatile_customers = customer_metrics[customer_metrics['Stability'] > 1.5]
        
        self.analysis_results['risk_indicators'] = {
            'top5_concentration': float(concentration),
            'volatile_customers': [
                {
                    'name': customer,
                    'volume': float(row['Total_Volume']),
                    'stability_score': float(row['Stability'])
                }
                for customer, row in volatile_customers.iterrows()
            ],
            'geographic_concentration': {
                country: float(pct) 
                for country, pct in (self.df.groupby('Country')['Amount'].sum() / 
                                    self.df['Amount'].sum() * 100).items()
            }
        }
        
        print("Analysis complete!")
        return self.analysis_results
    
    def export_for_visualization(self, filename='banking_analysis_results.json'):
        """Export analysis results to JSON for visualization"""
        with open(filename, 'w') as f:
            json.dump(self.analysis_results, f, indent=2)
        print(f"\nResults exported to {filename}")
        
        # Also create a data snippet for the HTML to use
        print("\nCreating HTML-ready data format...")
        
        # Create simplified format for direct embedding
        html_data = {
            'summary': self.analysis_results['basic_metrics'],
            'monthly_data': self.analysis_results['monthly_trends'],
            'segments': self.analysis_results['segment_summary'],
            'industries': self.analysis_results['industry_analysis'],
            'geography': self.analysis_results['geographic_distribution'],
            'flows': self.analysis_results['cross_border_flows'][:20],  # Top 20 flows
            'top_customers': sorted(self.analysis_results['customer_analysis'], 
                                  key=lambda x: x['total_volume'], reverse=True)[:10],
            'growth_leaders': sorted([
                {'name': k, **v} 
                for k, v in self.analysis_results['growth_analysis'].items()
            ], key=lambda x: x['growth_rate'], reverse=True)[:5],
            'risk_metrics': self.analysis_results['risk_indicators']
        }
        
        # Generate JavaScript variable for embedding
        js_data = f"const analysisData = {json.dumps(html_data, indent=2)};"
        
        with open('analysis_data.js', 'w') as f:
            f.write(js_data)
        
        print("Data exported for HTML visualization!")
        return html_data

# Main execution
if __name__ == "__main__":
    # Initialize analyzer
    analyzer = BankingTradeAnalyzer(n_rows=40000)  # Use 40k for demo, scale to 4M in production
    
    # Generate data
    df = analyzer.generate_data()
    
    # Perform analysis
    results = analyzer.analyze_data()
    
    # Export for visualization
    html_data = analyzer.export_for_visualization()
    
    # Display summary
    print("\n" + "="*60)
    print("ANALYSIS SUMMARY")
    print("="*60)
    print(f"Total Transactions: {results['basic_metrics']['total_transactions']:,}")
    print(f"Total Volume: ${results['basic_metrics']['total_volume']:,.2f}")
    print(f"Average Transaction: ${results['basic_metrics']['avg_transaction']:,.2f}")
    print(f"\nTop 5 Concentration: {results['risk_indicators']['top5_concentration']:.1f}%")
    print(f"Number of Volatile Customers: {len(results['risk_indicators']['volatile_customers'])}")
    
    print("\nTop 3 Growth Leaders:")
    for leader in html_data['growth_leaders'][:3]:
        print(f"  - {leader['name']}: {leader['growth_rate']:.1f}% growth")







==============

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Banking Trade Analysis Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.08);
        }
        h1 {
            color: #1e3a8a;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            color: #64748b;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        h2 {
            color: #2563eb;
            margin-top: 40px;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 10px;
        }
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #6b7280;
        }
        .error {
            background-color: #fee2e2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .metric-card {
            background: linear-gradient(135deg, #f8fafc 0%, #e0e7ff 100%);
            border: 1px solid #e5e7eb;
            padding: 20px;
            border-radius: 10px;
            transition: transform 0.2s;
        }
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #1e40af;
            margin-bottom: 5px;
        }
        .metric-label {
            color: #64748b;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .chart-container {
            margin: 30px 0;
            background: #fafafa;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 20px;
        }
        .table-container {
            overflow-x: auto;
            margin: 20px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        th, td {
            padding: 12px 16px;
            text-align: left;
        }
        th {
            background-color: #f8fafc;
            font-weight: 600;
            color: #1e3a8a;
            position: sticky;
            top: 0;
        }
        tr:hover {
            background-color: #f1f5f9;
        }
        tr:nth-child(even) {
            background-color: #fafafa;
        }
        .positive {
            color: #10b981;
            font-weight: 600;
        }
        .negative {
            color: #ef4444;
            font-weight: 600;
        }
        .insights-box {
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            border-left: 4px solid #3b82f6;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .alert-box {
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
            border-left: 4px solid #ef4444;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .opportunity-box {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border-left: 4px solid #22c55e;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .data-source {
            text-align: center;
            color: #6b7280;
            font-size: 0.9em;
            margin-top: 20px;
            padding: 10px;
            background-color: #f9fafb;
            border-radius: 6px;
        }
        .refresh-btn {
            background-color: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 10px;
        }
        .refresh-btn:hover {
            background-color: #2563eb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Dynamic Banking Trade Analysis Dashboard</h1>
        <p class="subtitle">Real-time insights powered by Python data analysis</p>
        
        <div class="data-source">
            Data Source: <span id="dataSource">Loading...</span>
            <button class="refresh-btn" onclick="loadData()">Refresh Data</button>
        </div>

        <div id="loadingMessage" class="loading">Loading analysis data...</div>
        <div id="errorMessage" class="error" style="display: none;"></div>
        <div id="dashboardContent" style="display: none;">
            <!-- Dashboard content will be dynamically generated here -->
        </div>
    </div>

    <script>
        // This will be populated by the Python script's output
        let analysisData = null;

        // Function to format currency
        function formatCurrency(value) {
            if (value >= 1e9) return `$${(value / 1e9).toFixed(2)}B`;
            if (value >= 1e6) return `$${(value / 1e6).toFixed(2)}M`;
            if (value >= 1e3) return `$${(value / 1e3).toFixed(2)}K`;
            return `$${value.toFixed(2)}`;
        }

        // Function to format numbers
        function formatNumber(value) {
            return value.toLocaleString();
        }

        // Function to load data (in production, this would fetch from an API)
        async function loadData() {
            try {
                // In a real application, this would be an API call:
                // const response = await fetch('/api/banking-analysis');
                // analysisData = await response.json();
                
                // For this demo, we'll simulate loading the data
                // In practice, the Python script would export this data
                simulateDataLoad();
                
                if (analysisData) {
                    document.getElementById('dataSource').textContent = 
                        `Python Analysis (${formatNumber(analysisData.summary.total_transactions)} transactions)`;
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('dashboardContent').style.display = 'block';
                    renderDashboard();
                }
            } catch (error) {
                showError('Failed to load analysis data: ' + error.message);
            }
        }

        // Simulate data loading (in production, this would be replaced by actual data loading)
        function simulateDataLoad() {
            // This data structure matches what the Python script exports
            analysisData = {
                summary: {
                    total_transactions: 40000,
                    total_volume: 4873245678.90,
                    avg_transaction: 121831.14,
                    std_transaction: 245678.90
                },
                monthly_data: {
                    months: ['2023-01', '2023-02', '2023-03', '2023-04', '2023-05', '2023-06',
                            '2023-07', '2023-08', '2023-09', '2023-10', '2023-11', '2023-12',
                            '2024-01', '2024-02', '2024-03', '2024-04', '2024-05', '2024-06'],
                    volumes: [185000000, 192000000, 213000000, 208000000, 224000000, 231000000,
                             245000000, 252000000, 268000000, 273000000, 289000000, 295000000,
                             302000000, 318000000, 334000000, 351000000, 367000000, 385000000]
                },
                segments: {
                    'Premium Stable': {
                        total_volume: 1452000000,
                        avg_transaction: 285000,
                        customer_count: 4
                    },
                    'Premium Volatile': {
                        total_volume: 897000000,
                        avg_transaction: 198000,
                        customer_count: 3
                    },
                    'High Frequency': {
                        total_volume: 1783000000,
                        avg_transaction: 45000,
                        customer_count: 8
                    },
                    'Standard': {
                        total_volume: 741245678.90,
                        avg_transaction: 78000,
                        customer_count: 5
                    }
                },
                geography: {
                    'Hong Kong': { total_volume: 2193000000, percentage: 45 },
                    'China': { total_volume: 1462000000, percentage: 30 },
                    'Singapore': { total_volume: 731000000, percentage: 15 },
                    'Japan': { total_volume: 341000000, percentage: 7 },
                    'Others': { total_volume: 146245678.90, percentage: 3 }
                },
                top_customers: [
                    { name: 'Beta Industries', total_volume: 731000000, industry: 'Manufacturing', growth_rate: 28 },
                    { name: 'Tech Corp Ltd', total_volume: 487000000, industry: 'Technology', growth_rate: 127 },
                    { name: 'Alpha Trading Co', total_volume: 389000000, industry: 'Trading', growth_rate: 15 }
                ],
                growth_leaders: [
                    { name: 'Tech Corp Ltd', growth_rate: 127 },
                    { name: 'Zeta Pharma', growth_rate: 89 },
                    { name: 'Gamma Electronics', growth_rate: 67 }
                ],
                risk_metrics: {
                    top5_concentration: 38.5,
                    volatile_customers: [
                        { name: 'Alpha Trading Co', stability_score: 2.3 },
                        { name: 'Delta Logistics', stability_score: 1.8 }
                    ]
                }
            };
        }

        // Function to show error messages
        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorMessage').style.display = 'block';
            document.getElementById('loadingMessage').style.display = 'none';
        }

        // Main function to render the dashboard
        function renderDashboard() {
            const content = document.getElementById('dashboardContent');
            
            // Clear existing content
            content.innerHTML = '';
            
            // 1. Summary Metrics
            content.innerHTML += `
                <h2>Executive Summary</h2>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">${formatNumber(analysisData.summary.total_transactions)}</div>
                        <div class="metric-label">Total Transactions</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${formatCurrency(analysisData.summary.total_volume)}</div>
                        <div class="metric-label">Total Volume</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${formatCurrency(analysisData.summary.avg_transaction)}</div>
                        <div class="metric-label">Average Transaction</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${analysisData.risk_metrics.top5_concentration.toFixed(1)}%</div>
                        <div class="metric-label">Top 5 Concentration</div>
                    </div>
                </div>
            `;
            
            // 2. Monthly Trend Chart
            content.innerHTML += '<div class="chart-container" id="monthlyTrendChart"></div>';
            renderMonthlyTrend();
            
            // 3. Geographic Distribution
            content.innerHTML += '<div class="chart-container" id="geoChart"></div>';
            renderGeographicDistribution();
            
            // 4. Customer Segments
            content.innerHTML += '<div class="chart-container" id="segmentChart"></div>';
            renderSegmentAnalysis();
            
            // 5. Top Customers Table
            content.innerHTML += `
                <h2>Top Customers by Volume</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Customer Name</th>
                                <th>Industry</th>
                                <th>Total Volume</th>
                                <th>Growth Rate</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${analysisData.top_customers.slice(0, 5).map(customer => `
                                <tr>
                                    <td><strong>${customer.name}</strong></td>
                                    <td>${customer.industry}</td>
                                    <td>${formatCurrency(customer.total_volume)}</td>
                                    <td class="${customer.growth_rate > 0 ? 'positive' : 'negative'}">
                                        ${customer.growth_rate > 0 ? '+' : ''}${customer.growth_rate}%
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            // 6. Insights and Recommendations
            content.innerHTML += `
                <h2>Actionable Insights</h2>
                
                <div class="opportunity-box">
                    <h3>🚀 Growth Opportunities</h3>
                    <ul>
                        ${analysisData.growth_leaders.slice(0, 3).map(leader => 
                            `<li><strong>${leader.name}</strong>: ${leader.growth_rate}% growth - Schedule immediate meeting to expand services</li>`
                        ).join('')}
                    </ul>
                </div>
                
                <div class="alert-box">
                    <h3>⚠️ Risk Alerts</h3>
                    <ul>
                        <li><strong>Concentration Risk:</strong> Top 5 customers represent ${analysisData.risk_metrics.top5_concentration.toFixed(1)}% of volume</li>
                        ${analysisData.risk_metrics.volatile_customers.slice(0, 2).map(customer =>
                            `<li><strong>${customer.name}</strong>: High volatility score of ${customer.stability_score.toFixed(1)} - Monitor closely</li>`
                        ).join('')}
                    </ul>
                </div>
                
                <div class="insights-box">
                    <h3>📊 Strategic Recommendations</h3>
                    <ul>
                        <li>Focus on high-growth Technology and Healthcare sectors showing >35% growth</li>
                        <li>Diversify geographic exposure - Hong Kong represents ${analysisData.geography['Hong Kong'].percentage}% of volume</li>
                        <li>Develop specialized products for high-frequency trading customers</li>
                        <li>Implement risk mitigation strategies for volatile customers</li>
                    </ul>
                </div>
            `;
        }

        // Function to render monthly trend chart
        function renderMonthlyTrend() {
            const trace = {
                x: analysisData.monthly_data.months,
                y: analysisData.monthly_data.volumes.map(v => v / 1e9), // Convert to billions
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Monthly Volume',
                line: { color: '#3b82f6', width: 3 },
                marker: { size: 8, color: '#3b82f6' }
            };

            const layout = {
                title: 'Monthly Transaction Volume Trend',
                xaxis: { 
                    title: 'Month',
                    tickangle: -45
                },
                yaxis: { 
                    title: 'Volume (USD Billions)',
                    tickformat: '.1f'
                },
                height: 400,
                margin: { t: 50, b: 100 }
            };

            Plotly.newPlot('monthlyTrendChart', [trace], layout);
        }

        // Function to render geographic distribution
        function renderGeographicDistribution() {
            const countries = Object.keys(analysisData.geography);
            const values = countries.map(c => analysisData.geography[c].total_volume);
            
            const trace = {
                labels: countries,
                values: values,
                type: 'pie',
                hole: 0.4,
                marker: {
                    colors: ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#6b7280']
                }
            };

            const layout = {
                title: 'Geographic Distribution of Transaction Volume',
                height: 400
            };

            Plotly.newPlot('geoChart', [trace], layout);
        }

        // Function to render segment analysis
        function renderSegmentAnalysis() {
            const segments = Object.keys(analysisData.segments);
            const volumes = segments.map(s => analysisData.segments[s].total_volume / 1e9);
            
            const trace = {
                x: segments,
                y: volumes,
                type: 'bar',
                marker: {
                    color: ['#3b82f6', '#ef4444', '#10b981', '#f59e0b']
                }
            };

            const layout = {
                title: 'Customer Segment Analysis',
                xaxis: { title: 'Segment' },
                yaxis: { 
                    title: 'Volume (USD Billions)',
                    tickformat: '.1f'
                },
                height: 400
            };

            Plotly.newPlot('segmentChart', [trace], layout);
        }

        // Load data when page loads
        window.onload = function() {
            loadData();
        };
    </script>
</body>
</html>


==========


"""
Banking Trade Analysis Integration Script
This script demonstrates how to connect Python analysis with HTML visualization
"""

import json
import os
from flask import Flask, render_template, jsonify
from datetime import datetime
import pandas as pd

# Import our analyzer (from the previous script)
from banking_analysis_pipeline import BankingTradeAnalyzer

# Initialize Flask app for serving the dashboard
app = Flask(__name__)

# Global variable to store analysis results
analysis_cache = None
last_update = None

def run_analysis(force_refresh=False):
    """Run the banking analysis and cache results"""
    global analysis_cache, last_update
    
    # Check if we need to refresh (every hour or forced)
    if force_refresh or analysis_cache is None or \
       (datetime.now() - last_update).seconds > 3600:
        
        print("Running fresh analysis...")
        analyzer = BankingTradeAnalyzer(n_rows=40000)  # Scale to 4M in production
        
        # Generate and analyze data
        analyzer.generate_data()
        analyzer.analyze_data()
        
        # Export results
        analysis_cache = analyzer.analysis_results
        last_update = datetime.now()
        
        # Save to file for backup
        analyzer.export_for_visualization('latest_analysis.json')
        
        print("Analysis completed and cached!")
    
    return analysis_cache

@app.route('/')
def dashboard():
    """Serve the main dashboard"""
    return render_template('dashboard.html')

@app.route('/api/analysis-data')
def get_analysis_data():
    """API endpoint to get analysis results"""
    try:
        data = run_analysis()
        
        # Format data for the dashboard
        formatted_data = {
            'summary': data['basic_metrics'],
            'monthly_data': data['monthly_trends'],
            'segments': data['segment_summary'],
            'industries': data['industry_analysis'],
            'geography': data['geographic_distribution'],
            'flows': data['cross_border_flows'][:20],
            'top_customers': sorted(
                data['customer_analysis'], 
                key=lambda x: x['total_volume'], 
                reverse=True
            )[:10],
            'growth_leaders': sorted([
                {'name': k, **v} 
                for k, v in data['growth_analysis'].items()
            ], key=lambda x: x['growth_rate'], reverse=True)[:5],
            'risk_metrics': data['risk_indicators'],
            'last_updated': last_update.isoformat()
        }
        
        return jsonify(formatted_data)
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/refresh-data', methods=['POST'])
def refresh_data():
    """Force refresh the analysis"""
    try:
        data = run_analysis(force_refresh=True)
        return jsonify({'status': 'success', 'message': 'Data refreshed successfully'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

def create_standalone_html():
    """Create a standalone HTML file with embedded data"""
    # Run analysis
    print("Generating standalone HTML dashboard...")
    data = run_analysis()
    
    # Format data for embedding
    formatted_data = {
        'summary': data['basic_metrics'],
        'monthly_data': data['monthly_trends'],
        'segments': data['segment_summary'],
        'industries': data['industry_analysis'],
        'geography': data['geographic_distribution'],
        'top_customers': sorted(
            data['customer_analysis'], 
            key=lambda x: x['total_volume'], 
            reverse=True
        )[:5],
        'growth_leaders': sorted([
            {'name': k, **v} 
            for k, v in data['growth_analysis'].items()
        ], key=lambda x: x['growth_rate'], reverse=True)[:3],
        'risk_metrics': data['risk_indicators']
    }
    
    # Read the HTML template
    with open('dashboard_template.html', 'r') as f:
        html_template = f.read()
    
    # Inject the data
    data_script = f"""
    <script>
        // Data generated by Python analysis at {datetime.now().isoformat()}
        const analysisData = {json.dumps(formatted_data, indent=2)};
        
        // Override the simulateDataLoad function
        function simulateDataLoad() {{
            // Data is already loaded from Python
            console.log('Using embedded Python data');
        }}
    </script>
    """
    
    # Insert data before closing body tag
    html_with_data = html_template.replace('</body>', data_script + '\n</body>')
    
    # Save the standalone file
    output_file = f'banking_dashboard_{datetime.now().strftime("%Y%m%d_%H%M%S")}.html'
    with open(output_file, 'w') as f:
        f.write(html_with_data)
    
    print(f"Standalone dashboard created: {output_file}")
    return output_file

def create_realtime_dashboard():
    """Create a real-time updating dashboard using websockets"""
    print("Setting up real-time dashboard...")
    
    # This would use Flask-SocketIO or similar for real-time updates
    # Example structure:
    """
    from flask_socketio import SocketIO, emit
    
    socketio = SocketIO(app)
    
    @socketio.on('request_update')
    def handle_update_request():
        data = run_analysis()
        emit('analysis_update', data)
    """
    pass

if __name__ == '__main__':
    print("Banking Trade Analysis Integration")
    print("=" * 60)
    
    # Option 1: Create standalone HTML with embedded data
    print("\nOption 1: Creating standalone HTML dashboard...")
    standalone_file = create_standalone_html()
    print(f"Open {standalone_file} in your browser to view the dashboard")
    
    # Option 2: Run Flask server for dynamic updates
    print("\nOption 2: Starting Flask server for dynamic dashboard...")
    print("Dashboard will be available at http://localhost:5000")
    print("API endpoint: http://localhost:5000/api/analysis-data")
    
    # Run initial analysis
    run_analysis()
    
    # Start Flask server
    app.run(debug=True, port=5000)

# ============================================
# PRODUCTION DEPLOYMENT OPTIONS
# ============================================

"""
1. BATCH PROCESSING WITH SCHEDULED UPDATES
   - Use Apache Airflow or cron to run analysis daily/hourly
   - Export results to data warehouse (e.g., PostgreSQL, MongoDB)
   - Dashboard reads from database
   
   Example cron job:
   0 * * * * /usr/bin/python3 /path/to/banking_analysis.py

2. STREAMING ANALYSIS
   - Use Apache Kafka for real-time trade ingestion
   - Process with Apache Spark Streaming
   - Update dashboard via WebSockets
   
3. MICROSERVICES ARCHITECTURE
   - Analysis service (Python/FastAPI)
   - Data storage service (PostgreSQL/TimescaleDB)
   - Dashboard service (React/Vue.js)
   - API Gateway (Kong/Nginx)

4. CLOUD DEPLOYMENT (AWS Example)
   - S3: Store raw trade data
   - Lambda: Run analysis functions
   - RDS: Store analysis results
   - CloudFront: Serve dashboard
   - API Gateway: Manage APIs

5. CONTAINERIZED DEPLOYMENT
   docker-compose.yml:
   ```yaml
   version: '3.8'
   services:
     analysis:
       build: ./analysis
       environment:
         - DB_CONNECTION=postgresql://...
     dashboard:
       build: ./dashboard
       ports:
         - "80:80"
     database:
       image: postgres:13
       volumes:
         - db_data:/var/lib/postgresql/data
   ```
"""

===========

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Banking Dashboard - JSON Data Integration</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        /* Previous styles remain the same */
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #1e3a8a; text-align: center; }
        .metric-card { background: #f8fafc; border: 1px solid #e2e8f0; padding: 20px; border-radius: 8px; margin: 10px 0; }
        .metric-value { font-size: 24px; font-weight: bold; color: #1e40af; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .status { text-align: center; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .success { background: #dcfce7; color: #166534; }
        .error { background: #fee2e2; color: #dc2626; }
        .info { background: #dbeafe; color: #1e40af; }
        .file-input-container { text-align: center; margin: 20px 0; padding: 20px; background: #f8fafc; border-radius: 8px; }
        input[type="file"] { margin: 10px; }
        button { background: #3b82f6; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; }
        button:hover { background: #2563eb; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Banking Trade Analysis Dashboard</h1>
        <p style="text-align: center; color: #64748b;">Load analysis results from Python-generated JSON</p>

        <div class="file-input-container">
            <h3>Load Analysis Data</h3>
            <p>Select the JSON file generated by the Python analysis script:</p>
            <input type="file" id="jsonFileInput" accept=".json">
            <button onclick="loadJsonFile()">Load Data</button>
            
            <div style="margin-top: 20px;">
                <p><strong>Or load sample data:</strong></p>
                <button onclick="loadSampleData()">Load Sample Analysis</button>
            </div>
        </div>

        <div id="status" class="status info">
            Waiting for data... Please load a JSON file or use sample data.
        </div>

        <div id="dashboard" style="display: none;">
            <!-- Summary Metrics -->
            <h2>Summary Metrics</h2>
            <div class="grid" id="metricsGrid"></div>

            <!-- Charts -->
            <div id="monthlyTrendChart" style="margin: 30px 0;"></div>
            <div id="segmentChart" style="margin: 30px 0;"></div>
            <div id="geographyChart" style="margin: 30px 0;"></div>

            <!-- Top Customers -->
            <h2>Top Customers</h2>
            <div id="customersTable"></div>

            <!-- Risk Indicators -->
            <h2>Risk Analysis</h2>
            <div id="riskAnalysis"></div>
        </div>
    </div>

    <script>
        let analysisData = null;

        // Function to load JSON file
        function loadJsonFile() {
            const fileInput = document.getElementById('jsonFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showStatus('Please select a JSON file first', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    processAnalysisData(data);
                    showStatus('Data loaded successfully from ' + file.name, 'success');
                } catch (error) {
                    showStatus('Error parsing JSON file: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        // Function to load sample data
        function loadSampleData() {
            // This simulates the structure from Python analysis
            const sampleData = {
                basic_metrics: {
                    total_transactions: 40000,
                    total_volume: 4873245678.90,
                    avg_transaction: 121831.14,
                    std_transaction: 245678.90
                },
                monthly_trends: {
                    months: ['2023-01', '2023-02', '2023-03', '2023-04', '2023-05', '2023-06'],
                    volumes: [185000000, 192000000, 213000000, 208000000, 224000000, 231000000]
                },
                segment_summary: {
                    'Premium Stable': { total_volume: 1452000000, customer_count: 4 },
                    'Premium Volatile': { total_volume: 897000000, customer_count: 3 },
                    'High Frequency': { total_volume: 1783000000, customer_count: 8 },
                    'Standard': { total_volume: 741245678.90, customer_count: 5 }
                },
                geographic_distribution: {
                    'Hong Kong': { total_volume: 2193000000, percentage: 45 },
                    'China': { total_volume: 1462000000, percentage: 30 },
                    'Singapore': { total_volume: 731000000, percentage: 15 }
                },
                customer_analysis: [
                    { name: 'Beta Industries', total_volume: 731000000, industry: 'Manufacturing' },
                    { name: 'Tech Corp Ltd', total_volume: 487000000, industry: 'Technology' },
                    { name: 'Alpha Trading Co', total_volume: 389000000, industry: 'Trading' }
                ],
                risk_indicators: {
                    top5_concentration: 38.5,
                    volatile_customers: [
                        { name: 'Alpha Trading Co', volume: 389000000, stability_score: 2.3 }
                    ]
                }
            };
            
            processAnalysisData(sampleData);
            showStatus('Sample data loaded successfully', 'success');
        }

        // Process and display the analysis data
        function processAnalysisData(data) {
            analysisData = data;
            document.getElementById('dashboard').style.display = 'block';
            
            // Render metrics
            renderMetrics();
            
            // Render charts
            renderMonthlyTrend();
            renderSegmentChart();
            renderGeographyChart();
            
            // Render tables
            renderCustomersTable();
            renderRiskAnalysis();
        }

        // Show status message
        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
        }

        // Format currency
        function formatCurrency(value) {
            if (value >= 1e9) return `$${(value / 1e9).toFixed(2)}B`;
            if (value >= 1e6) return `$${(value / 1e6).toFixed(2)}M`;
            return `$${value.toLocaleString()}`;
        }

        // Render summary metrics
        function renderMetrics() {
            const metrics = analysisData.basic_metrics;
            const grid = document.getElementById('metricsGrid');
            
            grid.innerHTML = `
                <div class="metric-card">
                    <div class="metric-value">${metrics.total_transactions.toLocaleString()}</div>
                    <div>Total Transactions</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${formatCurrency(metrics.total_volume)}</div>
                    <div>Total Volume</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${formatCurrency(metrics.avg_transaction)}</div>
                    <div>Average Transaction</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${analysisData.risk_indicators.top5_concentration.toFixed(1)}%</div>
                    <div>Top 5 Concentration</div>
                </div>
            `;
        }

        // Render monthly trend chart
        function renderMonthlyTrend() {
            const trends = analysisData.monthly_trends;
            
            const trace = {
                x: trends.months,
                y: trends.volumes.map(v => v / 1e6), // Convert to millions
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Monthly Volume',
                line: { color: '#3b82f6', width: 3 }
            };

            const layout = {
                title: 'Monthly Transaction Volume (in Millions)',
                height: 400,
                xaxis: { title: 'Month' },
                yaxis: { title: 'Volume (USD Millions)' }
            };

            Plotly.newPlot('monthlyTrendChart', [trace], layout);
        }

        // Render segment chart
        function renderSegmentChart() {
            const segments = analysisData.segment_summary;
            
            const trace = {
                labels: Object.keys(segments),
                values: Object.values(segments).map(s => s.total_volume),
                type: 'pie',
                hole: 0.4
            };

            const layout = {
                title: 'Customer Segment Distribution',
                height: 400
            };

            Plotly.newPlot('segmentChart', [trace], layout);
        }

        // Render geography chart
        function renderGeographyChart() {
            const geo = analysisData.geographic_distribution;
            
            const trace = {
                x: Object.keys(geo),
                y: Object.values(geo).map(g => g.total_volume / 1e9),
                type: 'bar',
                marker: { color: '#10b981' }
            };

            const layout = {
                title: 'Geographic Distribution (in Billions)',
                height: 400,
                xaxis: { title: 'Country' },
                yaxis: { title: 'Volume (USD Billions)' }
            };

            Plotly.newPlot('geographyChart', [trace], layout);
        }

        // Render customers table
        function renderCustomersTable() {
            const customers = analysisData.customer_analysis.slice(0, 5);
            
            const tableHtml = `
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="background: #f8fafc;">
                        <th style="padding: 10px; text-align: left;">Customer Name</th>
                        <th style="padding: 10px; text-align: left;">Industry</th>
                        <th style="padding: 10px; text-align: right;">Total Volume</th>
                    </tr>
                    ${customers.map(c => `
                        <tr>
                            <td style="padding: 10px; border-top: 1px solid #e5e7eb;">${c.name}</td>
                            <td style="padding: 10px; border-top: 1px solid #e5e7eb;">${c.industry}</td>
                            <td style="padding: 10px; border-top: 1px solid #e5e7eb; text-align: right;">${formatCurrency(c.total_volume)}</td>
                        </tr>
                    `).join('')}
                </table>
            `;
            
            document.getElementById('customersTable').innerHTML = tableHtml;
        }

        // Render risk analysis
        function renderRiskAnalysis() {
            const risk = analysisData.risk_indicators;
            
            const riskHtml = `
                <div style="background: #fee2e2; padding: 20px; border-radius: 8px; margin: 10px 0;">
                    <h3 style="margin-top: 0;">Concentration Risk</h3>
                    <p>Top 5 customers represent <strong>${risk.top5_concentration.toFixed(1)}%</strong> of total volume</p>
                </div>
                ${risk.volatile_customers && risk.volatile_customers.length > 0 ? `
                    <div style="background: #fef3c7; padding: 20px; border-radius: 8px; margin: 10px 0;">
                        <h3 style="margin-top: 0;">Volatile Customers</h3>
                        ${risk.volatile_customers.map(c => `
                            <p><strong>${c.name}</strong>: Stability score ${c.stability_score.toFixed(1)} (Volume: ${formatCurrency(c.volume)})</p>
                        `).join('')}
                    </div>
                ` : ''}
            `;
            
            document.getElementById('riskAnalysis').innerHTML = riskHtml;
        }
    </script>
</body>
</html>



========

"""
COMPLETE EXAMPLE: Banking Trade Analysis with Dynamic Visualization

This example shows how to:
1. Run the Python analysis
2. Export data to JSON
3. Load it in the HTML dashboard
"""

# Step 1: Run the analysis and generate JSON data
from banking_analysis_pipeline import BankingTradeAnalyzer
import json
import webbrowser
import os

def run_complete_analysis():
    """Run analysis and prepare data for visualization"""
    
    print("Starting Banking Trade Analysis...")
    print("=" * 60)
    
    # Initialize analyzer with your data size
    # For testing: 40,000 rows
    # For production: 4,000,000 rows
    analyzer = BankingTradeAnalyzer(n_rows=40000)
    
    # Generate the data
    print("\n1. Generating trade data...")
    df = analyzer.generate_data()
    print(f"   ✓ Generated {len(df):,} transactions")
    
    # Perform analysis
    print("\n2. Performing comprehensive analysis...")
    results = analyzer.analyze_data()
    print("   ✓ Analysis complete")
    
    # Export to JSON
    print("\n3. Exporting results to JSON...")
    analyzer.export_for_visualization('banking_analysis_results.json')
    print("   ✓ Exported to banking_analysis_results.json")
    
    # Create a combined HTML file with embedded data
    print("\n4. Creating HTML dashboard with embedded data...")
    create_dashboard_with_data(results)
    print("   ✓ Created banking_dashboard.html")
    
    return df, results

def create_dashboard_with_data(analysis_results):
    """Create an HTML file with embedded analysis data"""
    
    # Prepare data for embedding
    embedded_data = {
        'basic_metrics': analysis_results['basic_metrics'],
        'monthly_trends': analysis_results['monthly_trends'],
        'segment_summary': analysis_results['segment_summary'],
        'geographic_distribution': analysis_results['geographic_distribution'],
        'customer_analysis': analysis_results['customer_analysis'][:10],
        'risk_indicators': analysis_results['risk_indicators'],
        'industry_analysis': analysis_results['industry_analysis'],
        'cross_border_flows': analysis_results['cross_border_flows'][:20]
    }
    
    # HTML template with embedded data
    html_content = f'''<!DOCTYPE html>
<html>
<head>
    <title>Banking Analysis Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1400px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; }}
        h1 {{ color: #1e3a8a; text-align: center; }}
        .metrics {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 30px 0; }}
        .metric-card {{ background: #f8fafc; padding: 20px; border-radius: 8px; text-align: center; }}
        .metric-value {{ font-size: 2em; color: #1e40af; font-weight: bold; }}
        .chart {{ margin: 30px 0; padding: 20px; background: #fafafa; border-radius: 8px; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Banking Trade Analysis Dashboard</h1>
        <p style="text-align: center; color: #6b7280;">
            Generated on {analysis_results['basic_metrics']['date_range']['end']}
        </p>
        
        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value">{analysis_results['basic_metrics']['total_transactions']:,}</div>
                <div>Total Transactions</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">${analysis_results['basic_metrics']['total_volume']/1e9:.2f}B</div>
                <div>Total Volume</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">${analysis_results['basic_metrics']['avg_transaction']:,.0f}</div>
                <div>Average Transaction</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">{analysis_results['risk_indicators']['top5_concentration']:.1f}%</div>
                <div>Top 5 Concentration</div>
            </div>
        </div>
        
        <div class="chart" id="monthlyChart"></div>
        <div class="chart" id="segmentChart"></div>
        <div class="chart" id="geoChart"></div>
        <div class="chart" id="industryChart"></div>
    </div>
    
    <script>
        // Embedded data from Python analysis
        const analysisData = {json.dumps(embedded_data, indent=2)};
        
        // Monthly Trend
        Plotly.newPlot('monthlyChart', [{{
            x: analysisData.monthly_trends.months,
            y: analysisData.monthly_trends.volumes.map(v => v/1e6),
            type: 'scatter',
            mode: 'lines+markers',
            name: 'Monthly Volume'
        }}], {{
            title: 'Monthly Transaction Volume (USD Millions)',
            height: 400
        }});
        
        // Segment Distribution
        const segments = analysisData.segment_summary;
        Plotly.newPlot('segmentChart', [{{
            labels: Object.keys(segments),
            values: Object.values(segments).map(s => s.total_volume),
            type: 'pie',
            hole: 0.4
        }}], {{
            title: 'Customer Segment Distribution',
            height: 400
        }});
        
        // Geographic Distribution
        const geo = analysisData.geographic_distribution;
        Plotly.newPlot('geoChart', [{{
            x: Object.keys(geo),
            y: Object.values(geo).map(g => g.total_volume/1e9),
            type: 'bar',
            marker: {{ color: '#10b981' }}
        }}], {{
            title: 'Geographic Distribution (USD Billions)',
            height: 400
        }});
        
        // Industry Analysis
        const industries = analysisData.industry_analysis;
        Plotly.newPlot('industryChart', [{{
            x: Object.keys(industries),
            y: Object.values(industries).map(i => i.total_volume/1e9),
            type: 'bar',
            marker: {{ color: '#3b82f6' }}
        }}], {{
            title: 'Industry Distribution (USD Billions)',
            height: 400
        }});
    </script>
</body>
</html>'''
    
    # Save to file
    with open('banking_dashboard.html', 'w') as f:
        f.write(html_content)

# ========================================
# USAGE EXAMPLES
# ========================================

if __name__ == "__main__":
    # Example 1: Basic usage
    print("EXAMPLE 1: Basic Analysis")
    df, results = run_complete_analysis()
    
    # Open the dashboard in browser
    dashboard_path = os.path.abspath('banking_dashboard.html')
    print(f"\nOpening dashboard in browser: {dashboard_path}")
    webbrowser.open(f'file://{dashboard_path}')
    
    # Example 2: Custom analysis with specific filters
    print("\n\nEXAMPLE 2: Filtered Analysis for Technology Sector")
    analyzer = BankingTradeAnalyzer(n_rows=10000)
    df = analyzer.generate_data()
    
    # Filter for technology sector
    tech_df = df[df['Customer Industry'] == 'Technology']
    print(f"Technology sector transactions: {len(tech_df):,}")
    print(f"Technology sector volume: ${tech_df['Amount'].sum():,.2f}")
    
    # Example 3: Real-time monitoring setup
    print("\n\nEXAMPLE 3: Real-time Monitoring Setup")
    print("""
    For real-time monitoring:
    
    1. Set up a data pipeline:
       - Connect to your transaction database
       - Stream data using Kafka/RabbitMQ
       - Process with Python in real-time
    
    2. Update the dashboard:
       - Use WebSockets for live updates
       - Or refresh every X minutes via AJAX
    
    3. Sample code structure:
    """)
    
    print('''
    # Real-time data processor
    import asyncio
    from datetime import datetime
    
    async def process_live_trades():
        while True:
            # Fetch new trades from database
            new_trades = fetch_new_trades_since_last_update()
            
            # Update analysis
            analyzer.add_new_trades(new_trades)
            results = analyzer.analyze_data()
            
            # Push to dashboard
            await push_to_dashboard(results)
            
            # Wait before next update
            await asyncio.sleep(60)  # Update every minute
    ''')

# ========================================
# PRODUCTION TIPS
# ========================================

print("""

PRODUCTION DEPLOYMENT TIPS:
==========================

1. DATA HANDLING:
   - Use chunking for 4M+ rows: pd.read_csv('data.csv', chunksize=100000)
   - Consider using Dask for larger datasets
   - Cache intermediate results

2. PERFORMANCE:
   - Pre-aggregate data in database
   - Use materialized views for common queries
   - Implement pagination for large results

3. VISUALIZATION:
   - Consider using Dash or Streamlit for interactive dashboards
   - Implement drill-down capabilities
   - Add export functionality (PDF/Excel reports)

4. AUTOMATION:
   - Schedule analysis with Apache Airflow
   - Set up alerts for anomalies
   - Automate report generation and distribution

5. SECURITY:
   - Implement proper authentication
   - Use HTTPS for web dashboards
   - Encrypt sensitive data
   - Follow banking compliance requirements
""")
